1、能否解释一下什么是线程、进程、协程，他们之间的关系
答：进程：本质上是一个独立执行的程序，进程是操作系统进行资源分配和调度的基本概念，是操作系统进行资源分配和调度的独立单位;
    线程：是操作系统能够运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，一个进程可以有多个线程，每条线
    执行不同的任务，切换受系统控制;
    协程：又称为微线程，是一种用户态的轻量级线程，协程的上下问切换是由用户自己决定的，所以称为用户级别的线程，一个线程可以有
    多个协程，进程、线程都是同步机制，协程是异步机制;(JAVA中未实现协程，但是在Python，Lua，Go中有实现)
    关系：一个进程可以有多个线程，它允许计算机同时运行多个程序，线程是进程的最小执行单位，CPU的调度切换的是进程和线程，
    进程和线程多了之后会大量消耗CPU;
    线程是独立运行和独立调度的基本单位，CPU上真正执行的是线程，一个线程可以对应多个协程;
2、并发和并行的区别?
答：并发：一个CPU上同时运行多个任务，同时实际上是交替处理多个任务，程序中可以同时拥有两个或多个线程，当有多个线程在操作时， 如果一个系统
    只有一个CPU，则他根本不可能真正同时进行一个以上的线程，他只能把CPU运作时间分成若干个时间点，再将个时间段分配给各个线程执行;
    并行：多个CPU上同时处理多个任务，一个CPU执行一个进程时，另一个CPU执行另一个进程，两个进程可以独立运行，互不抢占CPU资源;
3、JAVA多线程的实现方式?
答：1、继承Thread类，重写run()方法，创建实例，执行start()
    好处：代码简单，直接操作;
    坏处：继承只能继承一个类，没法在继承其他的类;
    2、实现Runnable接口，实现run()方法，创建Thread对象，使用Runable接口的实现对象作为参数传递给Thread对象，调用start()
    好处：多线程可以实现多个，也可以进行继承一个类，扩展性强;
    坏处：没返回值，不能直接启动，需要构造一个Thread实例
    3、通过Callable和FutureTask方式
    4、创建线程池，自定义Runnable接口，实现run()方法，创建线程池，调用执行方法并传入对象
    优点：安全性能高，线程复用
    缺点：JDK1.5之后才有线程池，需要结合Runnable接口使用;
4、JAVA线程的状态有那些,都有什么作用?
答：JDK中线程状态有6种，JVM运行中有9种;
    常见的状态为：创建（new）,生成线程对象,但是并没有调用线程的start()方法;
               就绪（Runnable）,当调用start()之后线程进入就绪状态，但是此刻线程调用还没把线程设置为当前线程，未获得CPU使用权
               如果线程运行后，从等待或则睡眠中回来后，也会进入就绪状态;
               运行（Running），程序将处于就绪状态的线程设置为当前线程，获得了CPU使用权，这时进入运行状态
               阻塞（Blocked） 
                等待阻塞：进入该状态的线程需要等待其他线程做出一定动作(通知或中断)，这种状态下CPU不会分配，只有等待其它线程通知或者
                唤醒，也可能永久处于阻塞状态。例如：调用wait(状态会变成WAIT状态)，也可能通过sleep(状态就变为TIMED_WAITING状态)，
                join或者发出IO请求，阻塞结束后线程重新进入就绪状态;
                同步阻塞：线程在获取synchronized同步失败，锁被其他线程占用，他就会进入同步阻塞状态;
                    等待（WAITING）：进入该状态的线程需要等待特定的线程做出一些特定的动作(通知或中断)
                    超时等待（TIMED_WAITING）：该状态不同于WAITING状态，他可以在特定时间后自行唤醒;
               死亡（Dead）,线程从运行状态run()方法执行结束，该线程死亡，不能进入就绪状态;
5、JAVA线程常见的方法有那些，分别解释一下?
答：sleep(): 属于线程Thread的方法，让线程暂停一定时间后在恢复;交出CPU使用权但是不会释放锁
            进入阻塞状态TIME_WAITING，睡眠结束变为就绪状态(Runnable)
    yield():属于线程Thread的方法，暂停当前线程去执行其他线程，交出CPU使用权，但是不释放锁，
            作用：让相同优先级的线程轮流执行，非完全轮流;
            注意：不会让线程变为阻塞状态，直接变为就绪状态(Runnable)，只需要重新获取CPU使用权
    join():属于线程Thread的方法，在主线程上运行调用该方法会让主线程休眠，不会释放自己持有的锁
            让调用join()的线程先执行完毕，在执行其他线程;
    wait(): 属于Object类的方法，调用该方法，会释放锁，进入线程的等待队列，
            需要依靠notify()或则notifyAll()唤醒，或则wait(timeout)时间自动唤醒;
    notify(): 属于Object类的方法，唤醒在对象监视器上等待的某一个线程，选择是任意的;
    notifyAll(): 属于Object类的方法，唤醒在对象监视器上的全部线程;
    interrupted(): 属于Thread的方法测试当前线程是否中断，返回true或false;
6、平时业务中有使用过多线程吗?能举例几个多线程的业务场景吗?
答：1、异步任务，用户注册，发送短信或则邮箱信息，并异步存储到数据可以;
    2、定时任务：定期备份日志，备份数据库;
    3、分布式计算：hadoop处理任务MapReduce，master-wark(单机单进程)
7、能举例几个不是线程安全的数据结吗？
答：hashMap，ArrayList，LinkedList
8、在Java中可以采用哪些方式保证线程安全？
答：1、加锁，如synchronized/ReentrantLock加锁;
    2、使用volatile声明变量，但不能保证原子性(需要解释，一般来说线程安全也要保证原子性);
    3、使用线程安全类(原子类（automaticXXX），并发容器，同步容器CopyOnWriteArrayList/ConcurrentHashMap;
    3、ThreadLock使用本地私有变量，使用信号量Semaphore等;
9、了解volatile关键字吗？与synchronized有什么区别?
答：volatile是轻量级的synchronized，保证了共享变量的可见性，被volatile修饰的关键字，如果值发生了变化，其他线程立即可见
    避免了脏读现象;
    volatile保证了可见性，但是不能保证原子性;
    synchronized即保证了原子性又保证了可见性;
使用场景：1、不能修饰写入操作依赖当前值的变量，例如：num++、num=num+1,不是原子操作，表面是，但是字节码层面不止一步;
缺点：由于禁止了指令重排，JVM相关的优化也就没有了，效率偏低;
10、为什么会出现脏读?
答：java内存模型简称JMM模型;
    JMM规定所有的变量都存在主内存中，每个线程有自己的工作内存，线程对变量的操作都在工作内存中进行，不能直接对主内存进行操作;
    使用volatile关键字修饰变量;
    每次读之前必须从主内存获取属性最新值;
    每次写入要立刻写入到主内存中;
    volatile关键字修饰的变量可以实时看到自己在主内存中的值，加入线程1对变量V进行修改，那么线程2可以立即看见;
11、volatile可以避免指令重排，能否解释下什么是指令重排？
答：指令重排序分为两类 编译器重排和运行时重排
    JVM在编译java代码或则CPU执行JVM字节码的时，对现有的指令重新排序，主要是优化运行效率(不改变程序结果前提)
    虽然指令重排序可以提高运行效率，但是多线程中可能会影响结果;解决办法：内存屏障。
    内存屏障是指屏障指令，使CPU对屏障指令之前和之后的内存操作执行结果的一种约束;
    
--------------------------------------------并发------------------------------------------------
1、synchronized与ReentrantLock的区别是什么?用于哪些场景?
答：synchronized：1、JAVA内置关键字，是悲观锁会引起其他线程阻塞;
    2、无法判断是否获取锁的状态，锁可重入，不可中断，只能是非公平的;
    3、加锁解锁的过程是隐式的，不需要用户手动操作，优点是操作简单但是显得不够灵活;
    4、一般的并发场景使用足够，可以放在被递归执行的方法上，且不用担心线程最后能否释放锁;
    5、synchronized操作的是对象头中的mark word;
ReentrantLook：1、是Lock接口的实现类，悲观锁;
    2、可以判断是否获取锁的状态，可重入，可中断，可以是公平锁也可以是非公平锁;
    3、需要手动加锁和解锁，且解锁操作尽量在try-catch-finally的finally中执行，确保线程最终能释放锁;
    4、在复杂并发中使用，在重入时要保证重复获取锁的次数和重入次数一致，否则可能会导致其他线程无法获得改锁;
    5、创建的时候通过传进参数true创建公平锁，默认不传或者false创建为非公平锁;
    6、底层不同是AQS的state和FIFO队列来控制加锁，锁粒度更细;
2、说说你对synchronized的了解?
3、并发编程的3要素？
答：1、原子性：一个不可分割的颗粒，原子性是指一个或则多个操作要么全部成功要么全部失败，期间不能被打断，也不存在上下文切换，线程切换
    会带来原子性问题
    2、有序性：程序执行的顺序有代码的顺序执行，但是处理器可能会对指令进行重排序：
    JVM在编译java或者CPU执行JVM字节码时，对现有指令进行重排序，主要目的是为了优化效率(不改变运行结果)
    3、可见性：一个线程对共享变量A进行了修改，其他线程能立刻看见;
4、java线程常见的进程调度算法?
答：1、先来先服务调度算法：                  
    2、短作业优先调度算法：
    3、高响应比优化调度算法：
    4、时间片轮询调度算法：
    5、优先级调度算法：
5、java里面的锁有哪些，分别解释一下？
答：1、悲观锁：当线程操作数据时，总是会认为其他线程会修改数据，所以每次拿数据时，都会加锁使其他线程去拿数据时进入阻塞状态;
    如：synchronized
    2、乐观锁：当线程操作数据时，都认为其他线程不会修改数据，更新的时候会去判断别的线程是否更新数据，通过版本判断，如果数据被修改
    了就拒绝更新， 比如：CAS，通过原子性来保证数据同步，比如数据库的乐观锁，通过版本控制实现，CAS不会保证线程同步，乐观的认为数据
    在更新期间没有其他线程影响;
    小结：悲观锁适合于写操作多得多场景，乐观锁适合读操作多的场景,所以乐观锁的吞吐量比悲观锁大很多;
    3、公平锁：指多个线程根据获取锁的顺序来获取锁，简单的说就是，一个线程组里，保证每条线程都能拿到锁，
    比如：ReentrantLock(底层同步队列FIFO：先进先出的规则获取锁); 
    4、非公平锁：获取锁的方式是随机的，无法保证每个线程都能获取锁，只要有资源，不管线程组有多少个线程，都能去抢占，可能会
    导致某些线程饿死  例如：synchronized，ReentrantLock;
    小结：非公平锁的性能高于公平锁，公平锁等待会消耗CPU性能;
    5、可重入锁：也叫递归锁，外层获取锁后，内层也能继续获得锁，并且不发生死锁;
    6、不可重入锁：当线程执行某个方法时获取了锁，在方法中在获取锁时，就会被阻塞;
    小结：可重入锁一定程度上能避免死锁，synchronized，ReentrantLock重入锁;
    7、自旋锁：一个线程在获取锁时，如果这个锁已经被别的线程获取，这个线程就会循环等待，然后判断能不能换获取锁，
    知道获取锁才会退出循环，任何时候只会有一个执行单元获取锁;
    小结：线程状态不会发生改变，减少了用户态，减少了线程上下问切换，但是自旋会消耗CPU资源;常见自旋锁：TicketLock,CLHLock,MSCLock;
    8、共享锁：也叫S锁/读锁，能查看但是无法进行数据修改和删除的一种锁，加锁后用户可以并发，批量读取数据，该锁可以被多个线程锁持有，
    但是只能读数据，不能进行新增，删除，修改操作;
    9、互斥锁：也叫X锁，排它锁，写锁，独占锁，独享锁，该锁没次只能有一个线程持有，持有锁的线程可以对数据进行读和写，
    其他线程想要获取锁时会进入阻塞，直到当前线程解锁;
    10、死锁：两个或者两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞，若无外力的作用，将会一直
    维持该状态;
    下面是JVM为了提高所效率对synchronized锁升级，所得状态是通过对象监视器在对象头中的字段来表明，是不可逆的过程;
    11、偏量锁：一段同步代码一直被一个线程所访问，那么这个线程会自动获取锁，获取锁的代价更低;
    12、轻量级锁：当锁是偏量级锁的时候，被其他线程访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式等待;
    13、重量级锁：当锁是轻量级锁时，其他线程自然是自旋，但自旋一定次数后仍未获得锁，就会进入阻塞状态，转换成重量级锁，
    重量级锁会让未获得锁的线程全部变为阻塞，性能也会降低;
6、手写一个死锁的，并给出解决方法?
答：死锁发生的4个条件：互斥条件：资源不能共享，只能由一个线程使用
    请求与保持条件：线程已经获得一些资源，再去回去别的资源时发生阻塞，对现有的资源不释放
    不可抢占：有些资源是不可抢占的，某些线程获取之后，系统不能强行回收，只能有线程自己释放
    循环等待条件：多个线程形成环形链
7、对synchronized了解多少，新版JDK里做了什么优化?

8、了解CAS不，能否解释一下什么是CAS?
答：1、全称是Compare And Swap，即比较和交换，是实现并发应用的一种技术;
    2、底层通过使用Unsafe类实现原子操作，包含三个数的操作：内存地址(V)、预期原值(A)、新值(B);
    3、如果线程操作时预期原值与内存地址值一致，那么处理就就会自动更新该位置值为新值，如果在第一轮循环中，a线程
    获取的内存地址被b线程修改了，那么a线程就需要自旋，等待下一次执行;
    CAS属于乐观锁，性能相较与悲观锁有很大提高
    原子类AtomicXXX类的底层实现就是CAS,一定程度上性能比synchronized性能好;
9、CAS存在哪些比较严重的问题？
答：1、存在ABA问题
    2、自旋时间长CPU利用率增加，CAS里面是一个循环判断过程，如果线程一直没有获取到状态，CPU会一直被占用;
10、能否解释一下什么是ABA,如何解决?
答：ABA问题是指一个变量V初次读取是A值，并且在准备赋值的时候也是A值，能证明A值没被修改过吗？很显然不能，因为变量V有可能被
    其他线程锁修改回了A值，结果就会导致CAS操作认为从来没被修改过，从而给A赋值;
    注意：ABA问题，如果之关心结果的话无所谓，但是如果程序需要关心过程，则不行;
解决办法：给变量加上一个版本号，在每次比较的时候不仅需要比较值还需要比较版本号;
    从JDK1.5开始，已经提供了AtomicStampedReference来解决问题，检查当前引用是否等于预期引用，其次检查当前标志是否等于
    预期标志，如果相等就会采用原子方式将引用和标志都改变为新值;

    








