1、为什么用自增列做为主键？
答：为什么我们定义了主键（PRIMARY KEY），那么InnoDB会选择主键为聚集索引（如果没有显示定义，InnoDB会默认选择第一个不包含
    null的唯一索引作为主键索引）
    数据记录本身存于 b+tree 的叶子节点上，这就要求统一叶子节点内的各条数据记录按主键顺序存放
    如果使用自增列做主键，那么每次添加新的数据，就会顺序添加到当前节点的后续位置，当一页写满在开辟新的一页
    如果是非自增索引列，由于数值是随机的，则每次添加时会被插入到现有索引页中的某个位置（此时MySQL不得不为了将新记录插到合适位置⽽移动数据，甚⾄⽬标⻚⾯可能已经被回写到磁盘上⽽从缓存中清掉，此时⼜要从
    磁盘上读回来，这增加了很多开销）

2、为什么使用数据索引能提高效率？
答：索引的存储是有序的
    在有序的情况下，查询一个数据是无需遍历索引记录的
    极端情况下，索引的查询效率为二分查找的效率，时间复杂度趋近于O(log₂N)

3、B+树与hash索引的区别？
答：B+树是一个平衡多叉树，从根节点到叶子节点的高度差值不超过1，而且同层级的节点之间有指针相互连接，是有序的；
    哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点查到叶子节点逐级查找，只需要一次哈希算法即可，时无序的；

4、哈希索引的优势？
等值查询，（在没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，存在hash碰撞问题）哈希索引具有绝对优势；

5、哈希索引不适用的场景？
答：不支持范围查询
    不支持索引完成排序
    不支持联合索引的最左前缀匹配规则

6、MySQL联合索引？
答：联合索引是两个或者多个列上的索引（对于联合索引:Mysql从左到右的使⽤索引中的字段，⼀个查询可以只使⽤索引中的⼀部份，但只能是最左侧部分）
    利用索引的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引

7、什么情况下应不建或少建索引？
答：表记录太少
    经常插入、删除、修改的表
    数据重复且分布平均的表字段
    经常和主字段一块查询但主字段索引值比较多的表字段

8、什么是表分区？
答：表分区，是根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层确实多个物理分区组成；

9、表分区与分表的区别？
答：分表：通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间分成多个表；
    表分区：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表；

10、常说的事务的ACID是什么？
答：原子性（Atomicity）：一个事物不能被切分为更小单元，整个操作要么全部成功要么全部失败；
    一致性（Consistency）：数据库总能从一个一致性的状态转换为另一个一致性的状态，主要有任何一方发生异常，事务提交就会失败；
    隔离性（Isolation）：一个事务对另一个事务是隔离的，一个事务锁做的修改是最终提交以前，对其他事务是不可见的；
    持久性（Durability）：一旦事务提交，则其所作的修改回永久保存到数据库中；

11、解释脏读，不可重复读，幻读的意思？
答：脏读：事务A对数据进行操作，还未进行提交，此时B读到了A还未提交的数据，若事务A进行了回滚，就会导致事务B读取不到A修改的数据，这就是脏读；
    不可重复读：事务A对数据进行操作，事务B将同一条数据进行了修改，导致事务A再次获取数据时，拿到了不同的数据；
    幻读：在某个事务读取某个范围的数据时，另一个事务在该范围内又插入了几条数据，导致每次查询到的数据不一样，就像发生了幻觉一样；
    区别：
    幻读和不可重复读区别在于：前者是一个范围，后者是对同一条数据，但是两者都表现为两次读取的数据不一致；

12、mysql的事务隔离级别？
答：四种隔离级别：
    1、读未提交（read-uncommitted）:会发生脏读，可重复读，幻读
    2、读已提交/不可重复读（read-committed）:会发生可重复读、幻读
    3、可重复读（repeatable-read）：会发生幻读（mysql默认的事务隔离级别）
    4、串行化（serializable）：

13、如何防止事务并发问题？
答：1、事务隔离机制
    2、MVCC多版本隔离机制
    3、锁机制等

14、创建索引主要考虑些什么，使用索引的优缺点有哪些？应该注意什么？
答：考虑点：结合实际的业务场景，在哪些字段上创建索引，创建什么类型的索引
索引的好处：快速定位到表的位置，减少服务器的扫描次数；
          有些索引存储的实际的数据，特定的情况下只要使用索引就能完成查询；
索引的缺点：索引会浪费磁盘空间，不要创建非必要的索引
          插入，跟新，删除需要维护索引，带来额外的开销
          索引过多，修改表的时候重构索引性能差
索引优化实践：前缀索引，特别是TEXT和BLOG类型的字段，只检索前面几个字符，提高索引速度
            尽量使用数据量少的索引，索引值过长查询速度会受到影响
            选择合适的索引列顺序
            内容变动少，且查询频繁，可以考虑建立索引，内容变动频繁，谨慎创建索引
            组合索引选择业务最相关的字段

15、是否有大数据分页优化思路，线上一个商品表数据量过千万，做深度分页的时候性能慢，有什么优化思路
答：慢的原因 select语句执行limit进行分页的时候，需要先扫描到N行，再去取M行，N越大，扫描的条数越多，mysql性能越差
    解决方案：1、后端、前端缓存，使用ElasticSearch进行分页搜索
            2、合理使用MySQL查询缓存，覆盖索引进行分页（查询索引字段）
            3、如果id是自增，并且中间不存在删除的情况下，使用子查询优化，定位偏移位置的id（select * 和 select id）

16、生产环境的数据库，你会做哪些操作保证安全？
答：业务性能：1、应用上线前会审查业务新增的sql,和分析sql执行计划，例如：是否存在select *，索引创建是否合理
            2、开启慢查询日志，定期分析慢查询日志
            3、监控CPU/内存利用率，读写，网关IO，流量带宽
            4、吞吐量QPS/TPS，一天内读写随时间变化统计
    数据安全：1、短期增量备份，比如一周一次，定期全量备份，比如一月一次
            2、检查是否有非授权用户，是否存在弱口令，网络防火墙检查
            3、导出数据是否进行脱敏，防止数据泄露或黑产利用
            4、数据库，全量操作日志审计，防止数据泄露
            5、数据库账号密码，业务独立，权限独立控制，防止多库公用同个账号密码

17、你知道mysql有多少种日志，分别解释一下？
答：redo日志->重做日志 作用：确保事务的持久性，防止在发生故障，脏页未写入磁盘，重启数据库会进行redo log执行重做，达到事务一致性。
    undo->回滚日志  作用：保证数据的原子性，记录事务发生之前的数据的一个版本，用于回滚。
                    innodb事务的可重复读和读已提交 隔离级别就是通过mvcc+undo实现
    errorlog->错误日志  作用：mysql本身启动，停止，运行期间产生的错误信息
    slow query log->慢查询日志  作用：记录执行时间过长的sql，时间阈值可以记录，只记录执行成功的sql
    binlog->二进制日志  作用：用于主从复制，实现主从同步
    relay log->中继日志  作用：用于数据库主从同步，将主库法老的binlog先保存到本地，然后从库在进行回放
    general log->普通日志  作用：记录数据库操作明细，默认关闭，开启会降低数据库性能

 






